---
lastUpdated: true
prev: false
next: false
---

<script setup>
import { useData } from 'vitepress'
const { isDark } = useData()
</script>

#  《Feature》投稿格式指导

<ColorLine :height="4"/>
本文旨在为有意向《Feature》投稿的创作者提供投稿格式的规范和建议，以及列出了本站支持的特殊格式，以方便作者们进行运用。

## 投稿的格式规范

### 文本格式

《Feature》接受Markdown格式的投稿。  
如果你不熟悉Markdown，可以通过下面的教程快速上手：

- <https://commonmark.org/help/>
- <https://www.markdown.cn/docs/tutorial-basics/basic-syntax>

当然你也可以使用下面的在线编辑器体验：

- <https://ld246.com/guide/markdown>
- <https://milkdown.dev/playground>

### 文章结构

《Feature》对投稿的文章选题和行文格式没有硬性要求，与mc原版开发有关即可。编辑在采用时可能会结合文章的选题与作者进行一定的探讨和修改。

我们推荐在文章的开头附上本文的摘要。它会显示在索引页和文章的开头，是读者简略了解文章中心思想的有效工具。

关于文章中涉及到的图片或文件引用，如果需要本地引用的话，请将相应的图片和文件放在与文档同级的文件夹下，在投稿时打包发送。

### 投稿模板

我们推荐作者将文章、文章中使用的图片、以及一些其他信息打包成一个.zip压缩包发送到 <1703467028@qq.com> ；

压缩包中可以包含一个额外文件夹，在其中可以放置头图、作者的社媒账号信息、关于文章的其他说明等等；在收录时，其中的内容会被移动到别处。

下面是我们制作的示例模板，投稿者可以参考。

[示例模板.zip](/feature/example.zip)

## 附录：常见特殊格式参考

vitepress和本站在标准markdown语法之外进行了一些扩展，你可以自由使用这些新的语法优化你的文档排版

### 自定义注释块

vitepress新增了一些块级元素，你可以使用它们来制作注释：

```markdown
::: tip 提示标题
这里是提示的内容。
:::

::: warning 警告标题
这里是警告的内容。
:::

::: danger 错误标题
这里是错误的内容。
:::
```

它们会像下方所示渲染：

::: tip 提示标题
这里是提示的内容。
:::

::: warning 警告标题
这里是警告的内容。
:::

::: danger 错误标题
这里是错误的内容。
:::

如果你使用Typora编写Markdown，或许你更熟悉Github式风格的提示框。当然，Vitepress也对此有所支持。如下所示：

```markdown
> [!TIP]提示

> [!WARNING]警告

> [!DANGER]危险
```

### 折叠块

此外，vitepress加入了折叠块元素，你可以使用下面的方式使用它：

```markdown
::: details 折叠块
这里是被折叠的内容
:::
```

渲染效果如下：

::: details 折叠块
这里是被折叠的内容。
:::

### 公式
markdown支持两种类型的公式：

- 行内公式：使用单个`$`包裹公式块；
- 独占一行公式：另起一个段落，使用两个`$$`包裹公式块。

经测试，行内公式可能不支持较复杂的公式渲染，如有需求，尽量使用独占一行的公式块。

### 侧边栏
vitepress默认支持将2-6级标题自动整合为右侧侧边栏，作为索引导航。  
一级标题**默认不会自动整合**，作者投稿时需要注意，尽量减少使用一级标题。

### mcfunction、snbt和mcdoc语法支持

香草图书馆增加了mcfunction、snbt和mcdoc的代码块语法高亮，你可以和使用其他的编程语言一样使用它们：

```mcfunction
say mcf语法高亮
execute as @s at @s if entity @s run function foo:bar
tp @s ~ ~ ~ ~ ~
return 0
```

```mcdoc
struct myStruct{
	myInt: int,
	myShort: short,
	myString: string,
}
```

### NBT树展示支持

香草图书馆支持类似Wiki的NBT数据结构展示形式。如：

<div class="nbttree">

<node type="compound" name=""/> 这是结构根标签。
- <node type="string" name="string1"/>这是一个测试标签。
- <node type="string" name="string2" required=true />这是另一个测试标签，拥有代表必选项的红色星号。
- <node type="int" name="int1"/>这是一个整数测试标签。
- <node type="compound" name="compound1"/>这是一个复合标签测试。
  - <node type="float" name="float1"/>这是一个浮点数测试标签，同时作为上一个标签的下级标签。
  - <node type="list" name="list1"/>这是一个列表测试标签。
    - <node type="compound" name=""/>这是列表的一个项。
      - <node type="double" name="double1"/>这是一个双精度浮点数标签。
      - <node type="byte_list" name=""/><node type="int_list" name=""/><node type="long_list" name="multilist"/>这是一个泛型标签。它可能是字节、整型或长整型列表。
  - <node type="compound" name="compound2"/>这是另一个复合标签。<br>你可以用`<br>`另起一行，写一些内容，例如：当`foo`是`bar`时：
    -  <node type="bool" name="bool1"/>这是一个布尔值标签。
    -  <node type="any" name="any"/>这是一个任意值标签。
  - <node type="compound" name="compound3"/>这是折叠块样式测试。
    <details><summary>折叠块样式测试</summary>

    -  <node type="compound" name="compound4"/>在里面随便放一点标签。
        -  <node type="any" name="any"/>在里面随便放一点标签。
        -  <node type="compound" name="compound5"/>这是嵌套折叠块样式测试。
            <details><summary>嵌套折叠块样式测试1</summary>

             - <node type="any" name="any"/>在里面随便放一点标签。
             - <node type="any" name="any"/>在里面随便放一点标签。
            </details>
            <details><summary>嵌套折叠块样式测试2</summary>

             - <node type="any" name="any"/>在里面随便放一点标签。
            </details>

    </details>

- <node type="byte" name="byte1"/>这是一个字节型标签。特意写在了上面一个复合标签的下面，使结构不显得头重脚轻。
- <node type="homolist" name="homolist"/>这不是野兽先辈标签。它代表内部元素相同（元素可任意）的列表。

</div>

图书馆注册了全局css样式，可以使用`<div class=nbttree>`自定义类框架实现。  
注意div标签后需要**空一行**。

```html
<div class="nbttree">

<node type="compound" name=""/> 这是结构根标签。
- <node type="string" name="string1"/>这是一个测试标签。
- <node type="string" name="string2" required=true />这是另一个测试标签，拥有代表必选项的红色星号。
- <node type="int" name="int1"/>这是一个整数测试标签。
- <node type="compound" name="compound1"/>这是一个复合标签测试。
  - <node type="float" name="float1"/>这是一个浮点数测试标签，同时作为上一个标签的下级标签。
  - <node type="list" name="list1"/>这是一个列表测试标签。
    - <node type="compound" name=""/>这是列表的一个项。
      - <node type="double" name="double1"/>这是一个双精度浮点数标签。
      - <node type="byte_list" name=""/><node type="int_list" name=""/><node type="long_list" name="multilist"/>这是一个泛型标签。它可能是字节、整型或长整型列表。
  - <node type="compound" name="compound2"/>这是另一个复合标签。<br>你可以用`<br>`另起一行，写一些内容，例如：当`foo`是`bar`时：
    -  <node type="bool" name="bool1"/>这是一个布尔值标签。
    -  <node type="any" name="any"/>这是一个任意值标签。
  - <node type="compound" name="compound3"/>这是折叠块样式测试。
    <details><summary>折叠块样式测试</summary>

    -  <node type="compound" name="compound4"/>在里面随便放一点标签。
        -  <node type="any" name="any"/>在里面随便放一点标签。
        -  <node type="compound" name="compound5"/>这是嵌套折叠块样式测试。
            <details><summary>嵌套折叠块样式测试1</summary>

             - <node type="any" name="any"/>在里面随便放一点标签。
             - <node type="any" name="any"/>在里面随便放一点标签。
            </details>
            <details><summary>嵌套折叠块样式测试2</summary>

             - <node type="any" name="any"/>在里面随便放一点标签。
            </details>

    </details>

- <node type="byte" name="byte1"/>这是一个字节型标签。特意写在了上面一个复合标签的下面，使结构不显得头重脚轻。
- <node type="homolist" name="homolist"/>这不是野兽先辈标签。它代表内部元素相同（元素可任意）的列表。

</div>
```

在这个块内的无序列表样式会替换成类似wiki数据值版块的树结构。无序列表的层级代表nbt树的层级。  

此外我们还封装了一个vue组件来方便作者添加键类型和键名：

#### 键组件

使用自定义vue组件`<node />`添加一个键。该组件接受下列参数:


<div class="nbttree">

- <node type="string" name="type" required=true />键类型。影响图标显示。
- <node type="string" name="name"/>键名。缺省时不显示冒号。
- <node type="bool" name="required"/>是否为必选项。默认为false。设为true时渲染红色星号。
- <node type="bool" name="store"/>是否存储时必存在。默认为false。设为true时渲染蓝色星号。
- <node type="bool" name="colon"/>是否渲染冒号。默认为true。该值为false或缺省键名时，不显示冒号。

</div>

键类型可以为下列值之一，若没有对应的图标，则渲染为any。  
下面是键类型对照表：

|标识符|类型|符号|
|-|--|-|
|`any`|任意值| <node type="any" />|
|`bool`|布尔值| <node type="bool" />|
|`byte_list`|字节列表| <node type="byte_list" />|
|`byte`|字节型| <node type="byte" />|
|`list`|列表| <node type="list" />|
|`double`|双精度浮点数| <node type="double" />|
|`float`|单精度浮点数| <node type="float" />|
|`homolist`|同元素列表| <node type="homolist" />|
|`int_list`|整型列表| <node type="int_list" />|
|`int`|整型| <node type="int" />|
|`long_list`|长整型列表| <node type="long_list" />|
|`long`|长整型| <node type="long" />|
|`compound`|复合标签| <node type="compound" />|
|`short`|短整型| <node type="short" />|
|`string`|字符串| <node type="bool" />|

#### 折叠块
我们同样支持在NBT树中使用折叠块，并且注册了和wiki相似的蓝底样式。具体表现可以参见上面的示例。  
折叠块使用方法和一般HTML标签用法类似：
- 使用HTML标签`<detail>` `</detail>`包裹折叠块；
- 在`<detail>`后可以跟`<summary>` `</summary>`包裹摘要描述。

不过在md文档中混写折叠块HTML标签时需要注意以下几点：
- `<detail>`下面需要**空一行**，md的无序列表格式才能正确解析；
- `<detail>`和`</detail>`需要写在 **相同级数的缩进** 中；
- 折叠块内部的无序列表缩进 **必须不少于** 折叠块本身的缩进。

下面的写法是**正确的**：
```html
    <details><summary>折叠块样式测试</summary>

    -  <node type="compound" name="compound4"/>在里面随便放一点标签。
        -  <node type="any" name="any"/>在里面随便放一点标签。
        -  <node type="compound" name="compound5"/>这是嵌套折叠块样式测试。
            <details><summary>嵌套折叠块样式测试1</summary>

             - <node type="any" name="any"/>在里面随便放一点标签。
             - <node type="any" name="any"/>在里面随便放一点标签。
            </details>
            <details><summary>嵌套折叠块样式测试2</summary>

             - <node type="any" name="any"/>在里面随便放一点标签。
            </details>

    </details>
```

下面的写法是**错误的**：
```html
    <details><summary>折叠块样式测试</summary>

    -  <node type="compound" name="compound4"/>在里面随便放一点标签。
        -  <node type="any" name="any"/>在里面随便放一点标签。
        -  <node type="compound" name="compound5"/>这是嵌套折叠块样式测试。
            <details><summary>嵌套折叠块样式测试1</summary>

          - <node type="any" name="any"/>在里面随便放一点标签。
          - <node type="any" name="any"/>在里面随便放一点标签。
            </details>
            <details><summary>嵌套折叠块样式测试2</summary>
            - <node type="any" name="any"/>在里面随便放一点标签。
            </details>

</details>
```


#### 其他技巧

- 如果一个键可接受多个类型的值，你可以在同一行排列多个`node`组件，但只在最后一个组件填写`name`，`required`等参数。
- 由于nbt树的渲染依赖于无序列表，而markdown默认格式中，无序列表在一行内打断不会影响整个列表的渲染，你可以另起一行加入一些条件描述等。
  - 当然，在渲染上会显示为同一行。你还是需要使用`<br>`来换行。
  - 你也可以直接使用html标签`<ul>` `<li>`进行更加自定义的编写。
- 我们暂时暂未支持树内折叠块和共通标签的使用。后续可能会提供支持，敬请期待。